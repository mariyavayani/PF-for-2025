1480. Running sum of 1d array
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* runningSum(int* nums, int numsSize, int* returnSize) {
    
    int sum=0;
    int* runningSum = (int*)malloc(numsSize * sizeof(int));
    for (int i=0;i<numsSize;i++) {
        sum+=nums[i];
        runningSum[i]=sum;
    }
    *returnSize = numsSize;
    return runningSum;
}

3069. Distribute elements into two arrays I
int* resultArray(int* nums, int numsSize, int* returnSize) {
    int* arr1 = (int*)malloc(numsSize * sizeof(int));
    int* arr2 = (int*)malloc(numsSize * sizeof(int));
    int size1 = 0, size2 = 0;

    arr1[size1++] = nums[0];
    arr2[size2++] = nums[1];

    for (int i = 2; i < numsSize; i++) {
        if (arr1[size1 - 1] > arr2[size2 - 1])
            arr1[size1++] = nums[i];
        else
            arr2[size2++] = nums[i];
    }

    int* result = (int*)malloc(numsSize * sizeof(int));
    int index = 0;

    for (int i = 0; i < size1; i++)
        result[index++] = arr1[i];
    for (int i = 0; i < size2; i++)
        result[index++] = arr2[i];

    *returnSize = numsSize;
    free(arr1);
    free(arr2);

    return result;
}


2319. Check if matrix is X-Matrix
bool checkXMatrix(int** grid, int gridSize, int* gridColSize) {
    
    int flag1 = 1;
    int flag2 = 1;
    for (int i=0;i<gridSize;i++) {
        for (int j=0;j<gridSize;j++) {
            if (i==j || i==gridSize-1-j) {
                if (grid[i][j] == 0) {
                    flag1 = 0;
                }
            }
            else if (i!=j && j!=gridSize-1-i) {
                if (grid[i][j] != 0) {
                    flag2 = 0;
                }
            }
        }
    }
    if (flag1==1 && flag2 == 1) {
        return true;
    }
    else {
        return false;
    }
}
