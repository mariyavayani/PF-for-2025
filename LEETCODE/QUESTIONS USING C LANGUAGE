1480. Running sum of 1d array
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* runningSum(int* nums, int numsSize, int* returnSize) {
    
    int sum=0;
    int* runningSum = (int*)malloc(numsSize * sizeof(int));
    for (int i=0;i<numsSize;i++) {
        sum+=nums[i];
        runningSum[i]=sum;
    }
    *returnSize = numsSize;
    return runningSum;
}

3069. Distribute elements into two arrays I
int* resultArray(int* nums, int numsSize, int* returnSize) {
    int* arr1 = (int*)malloc(numsSize * sizeof(int));
    int* arr2 = (int*)malloc(numsSize * sizeof(int));
    int size1 = 0, size2 = 0;

    arr1[size1++] = nums[0];
    arr2[size2++] = nums[1];

    for (int i = 2; i < numsSize; i++) {
        if (arr1[size1 - 1] > arr2[size2 - 1])
            arr1[size1++] = nums[i];
        else
            arr2[size2++] = nums[i];
    }

    int* result = (int*)malloc(numsSize * sizeof(int));
    int index = 0;

    for (int i = 0; i < size1; i++)
        result[index++] = arr1[i];
    for (int i = 0; i < size2; i++)
        result[index++] = arr2[i];

    *returnSize = numsSize;
    free(arr1);
    free(arr2);

    return result;
}


2319. Check if matrix is X-Matrix
bool checkXMatrix(int** grid, int gridSize, int* gridColSize) {
    
    int flag1 = 1;
    int flag2 = 1;
    for (int i=0;i<gridSize;i++) {
        for (int j=0;j<gridSize;j++) {
            if (i==j || i==gridSize-1-j) {
                if (grid[i][j] == 0) {
                    flag1 = 0;
                }
            }
            else if (i!=j && j!=gridSize-1-i) {
                if (grid[i][j] != 0) {
                    flag2 = 0;
                }
            }
        }
    }
    if (flag1==1 && flag2 == 1) {
        return true;
    }
    else {
        return false;
    }
}

1232. Check if it is a straight line
bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize) {

    int x0 = coordinates[0][0]; 
    int y0 = coordinates[0][1];
    int x1 = coordinates[1][0];
    int y1 = coordinates[1][1];
    int x,y,flag=1;
    for (int i=2;i<coordinatesSize;i++) {
        x = coordinates[i][0];
        y = coordinates[i][1];
        if ((x - x0) * (y1 - y0) != (y - y0) * (x1 - x0)){
            flag = 0;
        }
    }
    if (flag==1){
        return true;
    }
    else{
        return false;
    }
}
        

2124. Check if all a's appear before all b's
bool checkString(char* s) {
    int flag = 1;
    for (int i=0;i<strlen(s)-1;i++) {
        if (s[i]=='b' && s[i+1]=='a') {
            flag = 0;
        }
    }
    
    if (flag==0) {
        return false;
    }
    else {
        return true;
    }
}

3232. Find if digit game can be won
bool canAliceWin(int* nums, int numsSize) {
    
    int flag = 0, double_sum=0,single_sum=0;
    for (int i=0;i<numsSize;i++){
        if (nums[i]/10 >=1) {
            double_sum += nums[i];
        }
        else {
            single_sum += nums[i];
        }
    }
    if (single_sum!=double_sum) {
        flag = 1;
    }

    if (flag==1) {
        return true;
    }
    else{
        return false;
    }
}

1880. Check if Word Equals Summation of Two Words
bool isSumEqual(char* firstWord, char* secondWord, char* targetWord) {
    char s[50] = "";
    char a[50] = "";
    char t[50] = "";
    int i=0, num1=0, num2=0,num3=0;
    while (firstWord[i] != '\0') {
        int digit = firstWord[i] - 'a';  
        num1 = num1 * 10 + digit;
        i++;
    }
    i = 0;
    while (secondWord[i] != '\0') {
        int digit = secondWord[i] - 'a';
        num2 = num2 * 10 + digit;
        i++;
    }
    i = 0;
    while (targetWord[i] != '\0') {
        int digit = targetWord[i] - 'a';
        num3 = num3 * 10 + digit;
        i++;
    }
    if (num1 + num2 == num3) {
        return true;
    } else {
        return false;
    }
    return 0;
}


69. Sqrt(x)
int mySqrt(int x) {
    return pow(x,0.5);
}

70. Climbing stairs
int climbStairs(int n) {
    int a = 0, b = 1, c;
    for (int i = 1; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}


125.Valid palindrome
bool isPalindrome(char* s) {
    char a[500]="";
    char r[500]="";

    for (int i=0;i<strlen(s);i++) {
        s[i] = tolower(s[i]);
        if ((s[i]>='a' && s[i]<='z') || (s[i]>='0' && s[i]<='9')) {
            char temp[2];
            temp[0] = s[i];
            temp[1] = '\0';
            strcat(a, temp);
        }
    }
    for (int i=strlen(a)-1;i>=0;i--) {
        char temp[2];
        temp[0] = a[i];
        temp[1] = '\0';
        strcat(r, temp);
    }
    if (strcmp(a,r)==0) {
        return true;
    }
    else {
        return false;
    }
}

367. Valid Perfect Square
bool isPerfectSquare(int num) {
    int sqrtNum = (int)sqrt(num);
    return sqrtNum * sqrtNum == num;
}

